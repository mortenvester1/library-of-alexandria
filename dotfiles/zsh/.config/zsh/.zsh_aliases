# following https://www.thorsten-hans.com/5-types-of-zsh-aliases

# Simple aliases
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."

# use gnu ls instad
alias ls="gls --color -alh --group-directories-first"
alias activate-venv="source .venv/bin/activate"

# Functions

# Docker - connect to a running container and start a bash session
docker-exec-bash() {
  docker exec -it $1 /bin/bash;
};

# Docker - Start Docker container and connect to it in bash session
docker-run-bash() {
  docker run -it $1 /bin/bash;
};

# Docker - Run a Docker container and forward all AWS environment variables
docker-run-with-aws-access(){
  docker run -it --env-file <(aws-vault exec $1 -- env | grep ^AWS_) $2
}

# Docker -  Remove all untagged images
docker-remove-none-images(){
    docker rmi -f $(docker images | grep '<none>' | sed  -E 's/[ ]+/,/g' | cut -f3 -d,)
}

# json <-> yaml conversion
yaml-to-json() {
	yq -P --output-format json $1
}
json-to-yaml() {
	yq -P $1
}
json-minify() {
	jq --compact-output < $1
}
json-maxify() {
	# uses two spaces by default
	jq < $1
}

# zinit update
zinit-update() {
  echo "Updating Zinit and plugins..."
  zinit self-update && zinit update --all
  echo "All Zinit plugins updated!"
}

# check login vs interactive - just for fun/learning
is-login-shell() {
	[[ -o login ]] && echo 'login' || echo 'non-login'
}
is-interactive-shell() {
	[[ $- == *i* ]] && echo 'interactive' || echo 'non-interactive'
}

# k9s
k9s-toogle-readonly() {
  CTX=$(kubectl config current-context)
  CLUSTER=$(kubectl config view --minify -o jsonpath='{.contexts[0].context.cluster}' | sed 's/[^a-zA-Z0-9]/-/g')
  yq -i '.k9s.readOnly |= not ' ${XDG_DATA_HOME}/k9s/clusters/${CLUSTER}/${CTX}/config.yaml
}

# reset zsh completions
zsh-completion-reset() {
  [ -s "${ZSH_COMPDUMP}" ] && rm ${ZSH_COMPDUMP}
}

# asdf
_asdf-read-to-associative-array() {
  local file_path="$1"
  local array_ref="$2"  # nameref to the associative array

  while IFS=' ' read -r tool version rest; do
      # Skip empty lines and comments
      if [[ -n "$tool" && "$tool" != \#* && -n "$version" ]]
      then
        local all_versions="$version"
        if [[ -n "$rest" ]]; then
          all_versions="$all_versions $rest"
        fi
        eval "${array_ref}[$tool]=\"$all_versions\""
      fi
  done < "$file_path"
}

asdf-merge() {
  # No local file to merge with, just move
  ASDF_DIR=${ASDF_DIR:-${XDG_CONFIG_HOME}/asdf}
  HEADER="# AUTOGENERATED $(date '+%Y-%m-%d %H:%M:%S')\n# DO NOT MODIFY DIRECTLY\n# MODIFY FILES IN ${ASDF_DIR}"
  if [ ! -s "${ASDF_DIR}/.tool-versions.local" ]
  then
    # cp "${ASDF_DIR}/.tool-versions" "${HOME}/.tool-versions"
    echo ${HEADER} > "${HOME}/.tool-versions"
    cat "${ASDF_DIR}/.tool-versions" >> "${HOME}/.tool-versions"
  else
    # Create associative arrays to store tools and versions
    declare -A base_tools
    declare -A local_tools
    declare -A all_tools

    _asdf-read-to-associative-array "${ASDF_DIR}/.tool-versions" base_tools
    _asdf-read-to-associative-array "${ASDF_DIR}/.tool-versions.local" local_tools

    # Merge logic: start with base tools, override with local versions
    for tool in ${(k)base_tools}; do
        if [[ -n "${local_tools[$tool]:-}" ]]; then
          # Combine local versions first, then base versions
          local combined="${local_tools[$tool]} ${base_tools[$tool]}"
          # Deduplicate versions while preserving order
          local -a versions_array
          local -A seen_versions
          local deduped=""

          for version in ${=combined}; do
              if [[ -z "${seen_versions[$version]:-}" ]]; then
                  seen_versions[$version]=1
                  deduped="$deduped $version"
              fi
          done
          all_tools[$tool]="${deduped# }"  # Remove leading space
        else
            # Use base version
            all_tools[$tool]="${base_tools[$tool]}"
        fi
    done

    # Add any additional tools from local that aren't in base
    for tool in ${(k)local_tools}; do
        if [[ -z "${base_tools[$tool]:-}" ]]; then
            all_tools[$tool]="${local_tools[$tool]}"
        fi
    done

    # write to file
    {
      echo "${HEADER}"
      for tool in $(printf '%s\n' ${(k)all_tools} | sort); do
          echo "$tool ${all_tools[$tool]}"
      done
    } > "${HOME}/.tool-versions"

  fi
}
