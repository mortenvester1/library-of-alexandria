{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Set Up Project Structure and Initialize Dependencies",
        "description": "Create the foundational directory structure for the project, including backend directories (e.g., `src/`, `tests/`), and initialize Python dependencies using `pyproject.toml`.",
        "details": "**Already Implemented:**\n- ✅ `src/alexandria_home/` directory with `__init__.py` and basic `main()` function\n- ✅ `pyproject.toml` with all required dependencies (FastAPI, Uvicorn, Jinja2, Pytest, Ruff, Pydantic, PyYAML)\n- ✅ `tests/` directory created\n- ✅ Ruff configuration in `pyproject.toml` (line-length: 120, excludes .venv)\n- ✅ Python 3.13 requirement (requires-python = \">=3.13\")\n\n**Minimal Changes Needed:**\n1. Create `src/alexandria_home/app.py` with a minimal FastAPI app\n2. Create `src/alexandria_home/config_parser.py` as a stub/placeholder module\n3. Run `uv sync --extra dev` to ensure dev dependencies (pytest) are installed\n4. Verify all tooling works correctly\n\n**Note:** Use `uvx ruff check` for linting and `uvx ruff format` for formatting (not plain `ruff` commands).",
        "testStrategy": "1. Run `uv sync --extra dev` to sync dependencies\n2. Run tests: `pytest`\n3. Validate formatting: `uvx ruff format src/`\n4. Validate linting: `uvx ruff check src/`\n5. Test FastAPI app: `uvicorn alexandria_home.app:app --reload` (verify it starts without errors)",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-08T02:17:35.694Z"
      },
      {
        "id": "2",
        "title": "Define YAML Configuration Schema and Loader",
        "description": "Implement a robust YAML configuration parser to read `config.yaml` and validate it against a predefined schema. Ensure the loader can dynamically extract app details (name, URL, port, description).",
        "details": "Create a Python module (`src/config_parser.py`) with:\n- A class `AppConfigParser` that loads `config.yaml`.\n- Validation logic to ensure required fields (`name`, `port`, `url`) are present and ports are valid integers.\n- Error handling for malformed YAML or missing keys (e.g., raise a descriptive exception).\n\nExample pseudo-code:\n```python\nfrom pydantic import BaseModel, ValidationError\nimport yaml\n\nclass AppConfig(BaseModel):\n    name: str\n    port: int\n    url: str  # e.g., 'http://localhost:8080'\n    description: str | None = None\n\nclass ConfigParser:\n    def __init__(self, config_path='config.yaml'):\n        self.config_path = config_path\n        self.apps = []\n\n    def load(self) -> list[AppConfig]:\n        with open(self.config_path, 'r') as f:\n            raw_config = yaml.safe_load(f)\n            if not raw_config:\n                raise ValueError('Empty YAML file')\n            self.apps = [AppConfig(**app) for app in raw_config]\n            return self.apps\n```",
        "testStrategy": "Write unit tests to verify:\n- Parsing valid `config.yaml` returns correct `AppConfig` objects.\n- Handling missing/invalid fields raises exceptions.\n- Port validation (e.g., rejects non-integers).\nUse Pytest fixtures for file operations.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-08T02:25:09.161Z"
      },
      {
        "id": "3",
        "title": "Implement FastAPI Backend Routes",
        "description": "Create FastAPI endpoints to:\n- Serve the main UI page (`GET /`).\n- Return a JSON list of apps (`GET /apps`).\n- Include a health check endpoint (`GET /health`).",
        "details": "Build a FastAPI app with routes using `src/main.py`:\n1. **Main UI Page (`/`)**: Render a Jinja2 template (e.g., `templates/index.html`) listing apps from the config parser.\n   - Pass dynamic data (app names, URLs) to the template.\n2. **Apps API (`/apps`)**: Return a JSON response of all apps parsed from YAML.\n3. **Health Check (`/health`)**: Simple endpoint returning `{\"status\": \"healthy\"}` for monitoring.\n\nExample pseudo-code:\n```python\nfrom fastapi import FastAPI, Request\nfrom fastapi.templating import Jinja2Templates\nfrom src.config_parser import ConfigParser\n\napp = FastAPI()\ntemplates = Jinja2Templates(directory='templates')\nparser = ConfigParser()\n\n@app.get('/')\ndef read_root(request: Request):\n    return templates.TemplateResponse('index.html', {\n        'request': request,\n        'apps': parser.apps\n    })\n\n@app.get('/apps')\ndef get_apps():\n    return parser.apps\n\n@app.get('/health')\ndef health_check():\n    return {'status': 'healthy'}\n```",
        "testStrategy": "Test endpoints with Pytest:\n- Verify `/` renders the correct HTML template.\n- Check `/apps` returns a valid JSON list of apps.\n- Confirm `/health` returns `{\"status\": \"healthy\"}`.\nUse FastAPI's built-in test client or `httpx` for HTTP requests.",
        "priority": "high",
        "dependencies": ["1", "2"],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-08T02:30:08.778Z"
      },
      {
        "id": "4",
        "title": "Set Up Jinja2 Templates for UI Rendering",
        "description": "Create a simple HTML template (`templates/index.html`) to display the list of apps dynamically. Include responsive design basics (e.g., grid layout, clickable links).",
        "details": "Design `index.html` as a Jinja2 template with:\n- A loop over `apps` to render tiles/links.\n- Example structure:\n  ```html\n  <!DOCTYPE html>\n  <html lang='en'>\n    <head>\n      <meta charset='UTF-8'>\n      <title>Local Gateway</title>\n      <style>\n        .app-card { display: grid; gap: 10px; }\n        .card { border: 1px solid #ddd; padding: 20px; text-align: center; } \n        .card a { color: blue; text-decoration: none; }\n      </style>\n    </head>\n    <body>\n      {% for app in apps %}\n        <div class='app-card'>\n          <div class='card'><a href='{{ app.url }}' target='_blank'>{{ app.name }}</a></div>\n        </div>\n      {% endfor %}\n    </body>\n  </html>\n  ```",
        "testStrategy": "Render the template with hardcoded apps (e.g., `parser.apps = [AppConfig(...)]`) and verify:\n- HTML structure is valid.\n- Links are correctly formatted (e.g., `<a href='http://localhost:8080'>`).\n- Responsive layout works in a browser (use Chrome DevTools).",
        "priority": "medium",
        "dependencies": ["3"],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-08T02:33:03.899Z"
      },
      {
        "id": "5",
        "title": "Configure `pyproject.toml` for Linting and Testing",
        "description": "Define `pyproject.toml` to:\n- Specify Python version (3.13).\n- Include FastAPI, Uvicorn, Jinja2, Pytest, and Ruff dependencies.\n- Set up linting rules (e.g., no unused imports) and test entry points.",
        "details": "Example `pyproject.toml`:\n```toml\n[tool.ruff]\nselect = ['E', 'F', 'W']\ndisallow-unused-variables = true\n[build-system]\nrequires = ['setuptools>=61.0.0']\nsetup-requires = ['pytest>=7.0.0']\n[project]\nscripts = {\n    \"test\" = \"pytest --maxfail=3 tests/\",\n    \"lint\" = \"ruff check .\"\n}\n```",
        "testStrategy": "Run `pyproject.toml` commands:\n- `python -m ruff check .` to lint the codebase.\n- `python -m pytest --maxfail=3 tests/` to run a minimal test suite.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-08T02:34:14.331Z"
      },
      {
        "id": "6",
        "title": "Create Dockerfile for Containerization",
        "description": "Write a multi-stage Dockerfile to build the FastAPI app efficiently. Use Python 3.13 as the base image and install dependencies in a minimal runtime environment.",
        "details": "Example Dockerfile:\n```dockerfile\n# Stage 1: Build\nFROM python:3.13-slim AS builder\nWORKDIR /app\nCOPY pyproject.toml .\nRUN pip install --user -e .\nCOPY . .\nRUN pip install --no-cache-dir ruff pytest\n\n# Stage 2: Runtime\nFROM python:3.13-slim\nWORKDIR /app\nENV PATH=/root/.local/bin:$PATH\nCOPY --from=builder /root/.local/lib/python3.13/site-packages .\nCOPY --from=builder /app/src ./src\nCOPY --from=builder /app/tests ./tests\nCOPY config.yaml .\nEXPOSE 8000\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```",
        "testStrategy": "Build and run the Docker image locally:\n- `docker build -t local-gateway .`\n- `docker run -p 8000:8000 --rm local-gateway`\nVerify the app serves `/`, `/apps`, and `/health` endpoints.",
        "priority": "medium",
        "dependencies": ["1", "2", "3"],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-10T14:17:33.971Z"
      },
      {
        "id": "7",
        "title": "Develop `docker-compose.yml` for Orchestration",
        "description": "Create a `docker-compose.yml` file to:\n- Run the FastAPI container.\n- Optionally include a YAML config service (e.g., for dynamic updates).\n- Define network isolation for local routing.",
        "details": "Example `docker-compose.yml`:\n```yaml\nversion: '3.8'\nservices:\n  gateway:\n    build: .\n    ports:\n      - \"8000:8000\"\n    networks:\n      - local_network\nnetworks:\n  local_network:\n    driver: bridge\n```",
        "testStrategy": "Deploy with `docker-compose up` and verify:\n- The container starts on port `8000`.\n- Access the UI at `http://localhost:8000/`.\n- Check `/apps` endpoint returns valid JSON.",
        "priority": "medium",
        "dependencies": ["6"],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-10T14:20:00.000Z"
      },
      {
        "id": "8",
        "title": "Implement Unit Tests for Core Logic",
        "description": "Write unit tests using Pytest to validate:\n- YAML config parsing.\n- FastAPI route logic (e.g., `/apps`, `/health`).\n- Template rendering (if applicable).",
        "details": "Example test structure (`tests/test_config_parser.py`):\n```python\nfrom src.config_parser import ConfigParser\nimport pytest\n\n@pytest.fixture\ndef valid_config():\n    return {\"app1\": {\"name\": \"App 1\", \"port\": 8080, \"url\": \"http://localhost:8080\"}}\n\ndef test_load_valid_config(valid_config):\n    parser = ConfigParser('tests/config.yaml')\n    assert len(parser.apps) == 1\n    assert parser.apps[0].name == 'App 1'\n```",
        "testStrategy": "Run `pytest` on the entire test suite. Focus on:\n- Parsing valid/invalid YAML.\n- Endpoint responses (e.g., `/apps` returns correct JSON).\n- Template rendering (if using Jinja2).",
        "priority": "medium",
        "dependencies": ["1", "2"],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-09T01:50:56.933Z"
      },
      {
        "id": "9",
        "title": "Add Security and Local Routing Safeguards",
        "description": "Ensure the app:\n- Only exposes ports within the local network (e.g., `0.0.0.0` binding with firewall rules).\n- Validates user-provided YAML data to prevent injection risks.\n- Uses HTTPS for all internal traffic (if applicable).",
        "details": "Implementation details:\n1. **Local Routing**: Modify FastAPI to bind to `0.0.0.0` and restrict external access via Docker network or firewall rules.\n2. **YAML Validation**: Enhance `AppConfigParser` to sanitize URLs/ports (e.g., reject non-local IPs).\n3. **HTTPS**: Use Uvicorn with SSL (if needed) or redirect HTTP traffic internally.\n\nExample pseudo-code:\n```python\n# In src/config_parser.py\nclass AppConfig(BaseModel):\n    url: str  # Validate URL uses localhost/127.0.0.1\n    port: int  # Ensure port is in valid range (e.g., 1-65535)\n```",
        "testStrategy": "Test with:\n- Hardcoded invalid URLs/IPs to ensure sanitization.\n- Verify Uvicorn binds to `0.0.0.0` and can be accessed locally only.",
        "priority": "medium",
        "dependencies": ["3"],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-09T01:55:27.053Z"
      },
      {
        "id": "10",
        "title": "Finalize Docker Compose and CI/CD Readiness",
        "description": "Refine `docker-compose.yml` for production-like deployment. Set up basic CI/CD pipelines (e.g., GitHub Actions) to run linting, tests, and builds on PRs.",
        "details": "Steps:\n1. Update `docker-compose.yml` with health checks or restart policies.\n2. Create a `.github/workflows/` directory for CI/CD:\n   ```yaml\n   name: CI\n   on: [push]\n   jobs:\n     test:\n       runs-on: ubuntu-latest\n       steps:\n         - uses: actions/checkout@v4\n         - run: python -m pytest --maxfail=3 tests/\n         - run: python -m ruff check .\n   ```",
        "testStrategy": "Deploy to a staging environment and verify:\n- Docker build/push works.\n- CI pipeline runs successfully on PRs.\n- End-to-end test suite passes (e.g., `/` + `/apps`).",
        "priority": "low",
        "dependencies": ["6", "7"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-09T01:52:03.517Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-10T14:20:00.000Z",
      "taskCount": 10,
      "completedCount": 9,
      "tags": ["master"]
    }
  }
}
